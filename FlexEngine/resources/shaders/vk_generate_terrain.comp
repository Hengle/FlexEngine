#version 450

#extension GL_EXT_scalar_block_layout : enable

#include "vk_noises.glsl"

#define MAX_NUM_ROAD_SEGMENTS					256
#define MAX_NUM_OVERLAPPING_SEGMENTS_PER_CHUNK	8
// TODO: Make specialization constant
#define MAX_VERTS_PER_TERRAIN_CHUNK_AXIS		32

layout (std430, binding = 0) uniform UBOConstant
{
	TerrainGenConstantData terrainGenConstantData;
} uboConstant;

layout (std430, binding = 1) uniform UBODynamic
{
	TerrainGenDynamicData terrainGenDynamicData;
} uboDynamic;

struct TerrainVertex
{
	float data[3 + 2 + 4 + 3];
	//vec3 positionWS;
	//vec2 uv;
	//vec4 colour;
	//vec3 normalWS;
};

layout (binding = 2) buffer TerrainVertexBuffer
{
	TerrainVertex vertices[];
};

layout (binding = 3) uniform sampler2DArray randomTables;

layout (local_size_x = MAX_VERTS_PER_TERRAIN_CHUNK_AXIS, local_size_y = 1, local_size_z = MAX_VERTS_PER_TERRAIN_CHUNK_AXIS) in;

void main()
{
	// TODO: Support LODs
	
	vec2 chunkIndex = uboDynamic.terrainGenDynamicData.chunkIndex;
	uint vertCountPerChunkAxis = uboConstant.terrainGenConstantData.vertCountPerChunkAxis;
	uint vertCountPerChunkAxisSq = vertCountPerChunkAxis * vertCountPerChunkAxis;
	uint vertexIndex_x = gl_GlobalInvocationID.x;
	uint vertexIndex_z = gl_GlobalInvocationID.z;
	uint linearChunkIndex = uboDynamic.terrainGenDynamicData.linearIndex;
	uint vertIndex = linearChunkIndex * vertCountPerChunkAxisSq + vertexIndex_x + vertexIndex_z * vertCountPerChunkAxis;
	float chunkSize = uboConstant.terrainGenConstantData.chunkSize;
	vec2 uv = clamp(vec2(vertexIndex_x / float(vertCountPerChunkAxis - 1), vertexIndex_z / float(vertCountPerChunkAxis - 1)), vec2(0.0), vec2(1.0));

	vec2 pos = vec2((chunkIndex.x + uv.x) * chunkSize, (chunkIndex.y + uv.y) * chunkSize);
	vec3 normal;
	vec4 terrainSample = SampleTerrain(uboConstant.terrainGenConstantData, randomTables, uboConstant.terrainGenConstantData.randomTableSize, pos, normal);
    float normalizedHeight = terrainSample.x;
    float height = (normalizedHeight - 0.5) * uboConstant.terrainGenConstantData.maxHeight;
	float blendWeight = terrainSample.y;
	float matID0 = terrainSample.z;
	float matID1 = terrainSample.w;

	vertices[vertIndex].data[0] = pos.x;
	vertices[vertIndex].data[1] = height;
	vertices[vertIndex].data[2] = pos.y;
	
	vertices[vertIndex].data[3] = uv.x;
	vertices[vertIndex].data[4] = uv.y;
	
	vertices[vertIndex].data[5] = normalizedHeight;
	vertices[vertIndex].data[6] = blendWeight;
	vertices[vertIndex].data[7] = matID0;
	vertices[vertIndex].data[8] = matID1;

	vertices[vertIndex].data[9] = normal.x;
	vertices[vertIndex].data[10] = normal.y;
	vertices[vertIndex].data[11] = normal.z;
}
