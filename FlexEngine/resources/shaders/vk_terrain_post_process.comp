#version 450

#extension GL_EXT_scalar_block_layout : enable

#include "vk_noises.glsl"

#define MAX_VERTS_PER_TERRAIN_CHUNK_AXIS		32
#define MAX_UINT								4294967295

struct TerrainGenPostProcessConstantData
{
	float chunkSize;
	float blendRadius;
	uint vertCountPerChunkAxis;
	uint vertexBufferSize;
	// NoiseFunction biomeNoise;
};

struct TerrainVertex
{
	float data[3 + 2 + 4 + 3];
	//vec3 positionWS;
	//vec2 uv;
	//vec4 colour;
	//vec3 normalWS;
};

struct TerrainGenPostProcessDynamicData
{
	uint neighborLinearIndexN;
	uint neighborLinearIndexE;
	uint neighborLinearIndexS;
	uint neighborLinearIndexW;
};

layout (std430, binding = 0) uniform UBOConstant
{
	TerrainGenPostProcessConstantData terrainGenPostProcessData;
} uboConstant;

layout (std430, binding = 1) uniform UBODynamic
{
	TerrainGenPostProcessDynamicData terrainGenPostProcessDynamicData;
	TerrainGenDynamicData terrainGenDynamicData;
} uboDynamic;

layout (binding = 2) buffer TerrainVertexBuffer
{
	TerrainVertex vertices[];
};

layout (local_size_x = MAX_VERTS_PER_TERRAIN_CHUNK_AXIS, local_size_y = 1, local_size_z = MAX_VERTS_PER_TERRAIN_CHUNK_AXIS) in;

void main()
{
	vec2 chunkIndex = uboDynamic.terrainGenDynamicData.chunkIndex;
	uint vertCountPerChunkAxis = uboConstant.terrainGenPostProcessData.vertCountPerChunkAxis;
	uint vertCountPerChunkAxisSq = vertCountPerChunkAxis * vertCountPerChunkAxis;
	uint vertexIndex_x = gl_GlobalInvocationID.x;
	uint vertexIndex_z = gl_GlobalInvocationID.z;
	uint linearChunkIndex = uboDynamic.terrainGenDynamicData.linearIndex;
	uint vertIndex = linearChunkIndex * vertCountPerChunkAxisSq + vertexIndex_x + vertexIndex_z * vertCountPerChunkAxis;
	float chunkSize = uboConstant.terrainGenPostProcessData.chunkSize;
	vec2 uv = clamp(vec2(vertexIndex_x / float(vertCountPerChunkAxis - 1), vertexIndex_z / float(vertCountPerChunkAxis - 1)), vec2(0.0), vec2(1.0));

	uint neighborLinearIndexN = uboDynamic.terrainGenPostProcessDynamicData.neighborLinearIndexN;
	uint neighborLinearIndexE = uboDynamic.terrainGenPostProcessDynamicData.neighborLinearIndexE;
	uint neighborLinearIndexS = uboDynamic.terrainGenPostProcessDynamicData.neighborLinearIndexS;
	uint neighborLinearIndexW = uboDynamic.terrainGenPostProcessDynamicData.neighborLinearIndexW;

	float avgHeight = 0.0;

	int sampledNeighbors = 0;
	float blendRadius = uboConstant.terrainGenPostProcessData.blendRadius;
	int blendRadiusI = int(blendRadius);
	//if (vertexIndex_x >= blendRadiusI && vertexIndex_x < vertCountPerChunkAxis - blendRadiusI &&
	//	vertexIndex_z >= blendRadiusI && vertexIndex_z < vertCountPerChunkAxis - blendRadiusI)

	if (neighborLinearIndexN == MAX_UINT || 
		neighborLinearIndexE == MAX_UINT || 
		neighborLinearIndexS == MAX_UINT || 
		neighborLinearIndexW == MAX_UINT)
	{
		avgHeight = 0.5;
	}
	else
	{
		for (int x = -blendRadiusI; x <= blendRadiusI; ++x)
		{
			for (int z = -blendRadiusI; z <= blendRadiusI; ++z)
			{
				int xx = int(vertexIndex_x) + x;
				int zz = int(vertexIndex_z) + z;
				int xo = (xx < 0) ? -1 : (xx >= vertCountPerChunkAxis) ? 1 : 0;
				int zo = (zz < 0) ? -1 : (zz >= vertCountPerChunkAxis) ? 1 : 0;
				uint neighborLinearIndex = (xo == -1) ? neighborLinearIndexW : (xo == 1) ? neighborLinearIndexE : (zo == -1) ? neighborLinearIndexN : (zo == 1) ? neighborLinearIndexS : linearChunkIndex;
				if (xo == -1) xx += int(vertCountPerChunkAxis) - 1;
				if (xo ==  1) xx -= int(vertCountPerChunkAxis) - 1;
				if (zo == -1) zz += int(vertCountPerChunkAxis) - 1;
				if (zo ==  1) zz -= int(vertCountPerChunkAxis) - 1;
				uint vertIndexN = neighborLinearIndex * vertCountPerChunkAxisSq + xx + zz * vertCountPerChunkAxis;
				// if (vertIndexN < uboConstant.terrainGenPostProcessData.vertexBufferSize)
				{
					float blendWeight = clamp((1.0 - abs(x) / blendRadius + 1.0 - abs(z) / blendRadius) * 0.5, 0.0, 1.0);
					avgHeight += vertices[vertIndexN].data[1];// * blendWeight;
					++sampledNeighbors;
				}
			}
		}
	}

	if (sampledNeighbors > 0)
	{
		avgHeight /= sampledNeighbors;
	}

	//float normalizedHeight = vertices[vertIndex].data[5];
	float blendWeight = clamp(vertices[vertIndex].data[6] * 2.0, 0.0, 1.0);
	vertices[vertIndex].data[1] = mix(vertices[vertIndex].data[1], avgHeight, blendWeight);
	//vertices[vertIndex].data[6] = clamp(avgHeight, 0.0, 1.0);
	
	//vertices[vertIndex].data[2] = 0.0;// mix(vertices[vertIndex].data[1], avgHeight, blendWeight);
	//vertices[vertIndex].data[3] = 0.0;// mix(vertices[vertIndex].data[1], avgHeight, blendWeight);
	//vertices[vertIndex].data[4] = 0.0;// mix(vertices[vertIndex].data[1], avgHeight, blendWeight);
}